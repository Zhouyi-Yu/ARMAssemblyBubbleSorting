# ARMAssemblyBubbleSorting
A Bubble Sort as a Lab Project build for ECE 212

Part A

This code is designed by first pushing the linked register and the general register 0 to 7 to the stack,  and printing out the welcome prompt on the screen. After these are set, the program starts to ask input from the user and put it into r4 and r6. Checking the range r4 is between 3 and 10, we will receive the number of entries which will later be our counter, and the input process will repeat if the user gives the invalid number of entries; the screen will display the prompt that tells the user what they did wrong and go back to the input section.  Then, the program will enter the VALUES section, where we grab the input from the user and store it in R5. However, we need to make sure the input number is not negative. If it is negative, then the program will enter the VALUEERROR and go back to the input values section. If it’s a valid input, then we will put the value of R5 into R7, where the memory starts. Then, we will raise the address of R5 by #4 so it can take the next input and decrease r6, which is functioned as a counter, by 1. This process will repeat until r6 reaches #1, where we will enter the FINALVALUE section that will take the last number of entry streams. In there, if the r5 is negative, then it will go to VALUEERRORFINAL section, which will print a prompt to tell the user that they need to enter a non-negative integer and go back to FINALVALUE. If the entry is valid, then we store r5 into r7. Then, we store the r4 into the address that stack pointer is pointing to plus #36. Finally we popped out all 8 general registers(0~7) and the program counter. 

Part B
This code began by loading all the data required which included getting the number of entries which would act as a counter and the starting address containing the elements to be sorted. Then two ‘’loops” were created by branching to them based on the counter not hitting zero. The outer loop would run based on the number of entries as well as the inner loops meaning this would effectively be a nested loop running n^2 times where n is the number of items that need to be sorted.  the inner loop would run n times where each time the item at the current index would be compared to the item at the next index which are located 4 bytes further than the current. If the current index is larger then the two would be swapped by storing the item in the current index which is loaded in a register into the next index and vice versa for the next index. If the current was smaller than the next then the inner loop counter would just decrease by one and keep running. When the outer loop hits zero that means every index has been compared to each other which results in the larger numbers “bubbling” themselves to the top in order of size. 

For an example of how the minimum and maximum values would be found we can look at the array [3,4,1,2]. The outer loop would run 4 times as well as the inner loop. The inner loop would first compare 3 and 4 and not switch since 3 is smaller than 4. Then it would compare 4 and 1 and switch them since 1 is smaller than 4 resulting in [3,1,4,2]. Then it would compare 4 and 2 resulting in [3,1,2,4] finishing our inner loop and finding our max value of 4. the counters would be adjusted accordingly and the inner loop would run again doing the comparisons resulting in [1,2,3,4]. Therefore finding the minimum value of 1. (Based on how the code was written the inner loop would run two more times since the counter for the outer loop was 4. This code could be optimized more for sure but in this case it's not necessary since our data sizes are so small and assembly is so quick. Bubble Sort would not be used in real life applications either way)

